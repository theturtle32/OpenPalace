<?xml version="1.0" encoding="utf-8"?>

<!--
This file is part of OpenPalace.

OpenPalace is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenPalace is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenPalace.  If not, see <http://www.gnu.org/licenses/>.
-->

<s:Group xmlns:mx="library://ns.adobe.com/flex/halo"
	width="{backgroundImage.width}" height="{backgroundImage.height}"
	minWidth="512" minHeight="384"
	clipAndEnableScrolling="true"
	xmlns:view="net.codecomposer.palace.view.*"
	creationComplete="handleCreationComplete()" xmlns:s="library://ns.adobe.com/flex/spark" xmlns:fx="http://ns.adobe.com/mxml/2009">

	<s:layout>
		<s:BasicLayout />
	</s:layout>

	<fx:Script>
		<![CDATA[
			import net.codecomposer.palace.model.PalaceConfig;
			import net.codecomposer.palace.model.PalaceProp;
			import spark.effects.Fade;
			import mx.collections.ArrayCollection;
			import net.codecomposer.palace.model.ChatMessage;
			import flash.utils.setTimeout;
			import mx.core.UIComponent;
			import mx.binding.utils.BindingUtils;
			import net.codecomposer.palace.event.PalaceRoomEvent;
			import net.codecomposer.palace.event.AvatarSelectEvent;
			import net.codecomposer.palace.event.ChatEvent;
			import net.codecomposer.palace.model.PalaceCurrentRoom;
			import net.codecomposer.palace.rpc.PalaceClient;
			import mx.events.PropertyChangeEvent;
			import net.codecomposer.palace.model.PalaceUser;
			import mx.binding.utils.ChangeWatcher;
			import net.codecomposer.palace.model.PalaceCurrentRoom;
			[Bindable]
			public var room:PalaceCurrentRoom;
			
			[Bindable]
			public var mediaServer:String;
			
			private var avatarsByUser:Dictionary = new Dictionary();
			private var nameTagsByUser:Dictionary = new Dictionary();
			
			private var baseBackgroundFile:String;
			private var forcingPng:Boolean = false;
			private var forcingJpeg:Boolean = false;
			
			private function handleCreationComplete():void {
				this.addEventListener(MouseEvent.CLICK, handleClick);
				room.addEventListener(ChatEvent.CHAT, handleChat);
				room.addEventListener(ChatEvent.ROOM_MESSAGE, handleChat);
				room.addEventListener(ChatEvent.WHISPER, handleChat);
				room.addEventListener(PalaceRoomEvent.ROOM_CLEARED, handleRoomCleared);
				room.addEventListener(PalaceRoomEvent.USER_ENTERED, handleUserEntered);
				room.addEventListener(PalaceRoomEvent.USER_LEFT, handleUserLeft);
				ChangeWatcher.watch(room, 'backgroundFile', handleBGChange);
			}
			
			private function handleClick(event:MouseEvent):void {
				var x:int = this.contentMouseX;
				var y:int = this.contentMouseY;
				if (x < 22) { x = 22; }
				if (y < 22) { y = 22; }
				if (x > width - 22) { x = width - 22; }
				if (y > height - 22) { y = height - 22; }
				trace("Movement requested x:" + x + " y:" + y);
				var socket:PalaceClient = PalaceClient.getInstance();
				socket.move(x, y);
			}
			
			private function handleAvatarClick(event:MouseEvent):void {
				if (event.currentTarget is Avatar) {
					var user:PalaceUser = Avatar(event.currentTarget).user;
					trace("Clicked avatar " + user.id + " - self is " + room.selfUserId);
					if (user.isSelf) {
						room.selectedUser = null;
					}
					else if (room.selectedUser != user) {
						event.stopPropagation();
						room.selectedUser = user;
					}
					else if (room.selectedUser == user) {
						event.stopPropagation();
						room.selectedUser = null;
					}
					updateAvatarTransparencies();
				}
			}
			
			private function updateAvatarTransparencies():void {
				//trace("Updating avatar transparencies");
				for each (var avatar:Object in avatarsByUser) {
					var av:Avatar = Avatar(avatar);
					if (room.selectedUser == null || av.user.id == room.selfUserId || av.user == room.selectedUser) {
						//trace("User " + av.user.id + " is self or selected user or no user is selected");
						av.alpha = 1;
					}
					else {
						//trace("User " + av.user.id + " is not the selected user (" + room.selectedUser.id + ")");
						av.alpha = 0.6;
					}
				}
			}
			
			private var stickyMessagesByUser:Dictionary = new Dictionary();
			private var currentlyDisplayedChatMessages:ArrayCollection = new ArrayCollection();
			private var chatQueue:Array = [];
			
			private function handleChat(event:ChatEvent):void {
				
				if (event.logOnly) { return; }
				
				var message:ChatMessage = new ChatMessage();
				message.isWhisper = event.whisper;
				message.text = event.chatText;
				message.tint = event.user ? Avatar.chatBubbleTintColors[event.user.color] : 0xF9F9F9;
				message.user = event.user;
				if (event.user) {
					message.x = event.user.x;
					message.y = event.user.y;
				}
				else {
					message.x = 0;
					message.y = 10;
				}
				
				chatQueue.push(message);
				
				checkChatQueue();
			}
			
			private function checkChatQueue():void {
				var itemsInQueue:int = chatQueue.length;
				
				for (var i:int = 0; i < itemsInQueue; i ++) {
					var message:ChatMessage = chatQueue.shift();
					if (!displayChatBubble(message)) {
						// If we're not currently able to display the chat bubble,
						// put it back on the queue.
						trace("Didn't successfully display message.");
						chatQueue.push(message);
					}
				}
			}
			
			// return true for success, false to put it back on the queue
			private function displayChatBubble(message:ChatMessage):Boolean {
				
				if (message.user && stickyMessagesByUser[message.user]) {
					var oldMessage:ChatMessage = stickyMessagesByUser[message.user];
					try {
						delete stickyMessagesByUser[message.user];
					}
					catch (e:Error) { /* do nothing */ }
					try {
						textGroup.removeElement(oldMessage.chatBubble);
					}
					catch (e:Error) { /* do nothing */ }
				}
				
				var chatBubble:ChatBubble = new ChatBubble();
				chatBubble.setStyle('skinClass', Class(net.codecomposer.palace.view.ChatBubbleSkin));
				chatBubble.text = message.text;
				chatBubble.x = message.x;
				chatBubble.y = message.y;
				chatBubble.isWhisper = message.isWhisper;
				chatBubble.tintColor = message.tint;
				chatBubble.visible = true;
				
				var overlapped:Boolean = false;
				
				// Check for overlaps...
				textGroup.addElement(chatBubble)
				chatBubble.validateNow();
				for (var positionNumber:int = 0; positionNumber < 4; positionNumber ++) {
					overlapped = false;

					// Check if we're running off the edge of the screen
					//trace(chatBubble.skin.currentState);

					var skinState:String = chatBubble.skin.currentState;
					var rightCheck:int, leftCheck:int, bottomCheck:int, topCheck:int;
					
					
					if (skinState.indexOf('Right') != -1) {
						rightCheck = chatBubble.x + chatBubble.skin.x + chatBubble.skin.measuredWidth;
						leftCheck = chatBubble.x + chatBubble.skin.x;
					}
					if (skinState.indexOf('Left') != -1) {
						rightCheck = chatBubble.x + chatBubble.skin.x;
						leftCheck = chatBubble.x + chatBubble.skin.x - chatBubble.skin.measuredWidth;
					}
					if (skinState.indexOf('bottom') != -1) {
						bottomCheck = chatBubble.y + chatBubble.skin.y + chatBubble.skin.measuredHeight;
						topCheck = chatBubble.y + chatBubble.skin.y;
					}
					if (skinState.indexOf('top') != -1) {
						bottomCheck = chatBubble.y + chatBubble.skin.y;
						topCheck = chatBubble.y + chatBubble.skin.y - chatBubble.skin.measuredHeight;
					}
					 
					if (
							rightCheck > width ||
							bottomCheck > height ||
							leftCheck < 0 ||
							topCheck < 0
					   ) { 
					   	overlapped = true;
						chatBubble.tryNextPosition();
						chatBubble.validateNow();
						continue;
					}
					
					innerLoop: for (var i:int = 0; i < currentlyDisplayedChatMessages.length; i ++) {
						var m:ChatMessage = ChatMessage(currentlyDisplayedChatMessages.getItemAt(i));
						if (m.chatBubble.hitTestObject(chatBubble)) {
							overlapped = true;
							chatBubble.tryNextPosition();
							chatBubble.validateNow();
							break innerLoop;
						}
					}
					if (!overlapped) {
						break;
					}
				}
				
				if (overlapped) {
					//trace("unresolvable overlap detected.");
					textGroup.removeElement(chatBubble);
					return false;
				}
				
				chatBubble.visible = true;
				message.chatBubble = chatBubble;
				
				if (!message.isStickyBubble) {
					setTimeout(removeChatBubble, 3000 + (message.text.length * 70), message);
				}
				else if (message.user) {
					stickyMessagesByUser[message.user] = message;
				}
				currentlyDisplayedChatMessages.addItem(message);
				return true;
			}
			
			private function removeChatBubble(message:ChatMessage):void {
				try {
					currentlyDisplayedChatMessages.removeItemAt(currentlyDisplayedChatMessages.getItemIndex(message));
					textGroup.removeElement(message.chatBubble);
				}
				catch (e:Error) { /* do nothing */ }
				
				checkChatQueue();
			}
			
			private function handleUserEntered(event:PalaceRoomEvent):void {
				var avatar:Avatar = new Avatar();
				avatar.user = event.user;
				avatar.alpha = 1;
				avatar.addEventListener(MouseEvent.CLICK, handleAvatarClick);
				avatarsGroup.addElement(avatar);
				avatar.validateDisplayList();
				avatarsByUser[event.user] = avatar;
				updateAvatarTransparencies();
				
				var nameTag:NameTag = new NameTag();
				nameTag.user = event.user;
				nameTagsByUser[event.user] = nameTag;
				nameTag.alpha = 0;
				nameTagGroup.addElement(nameTag);
				
				var fade:Fade = new Fade(nameTag);
				fade.duration = 700;
				fade.startDelay = int(Math.random() * 400);
				fade.alphaFrom = 0;
				fade.alphaTo = 1;
				fade.play();
			}
			
			private function handleUserLeft(event:PalaceRoomEvent):void {
				var avatar:Avatar = avatarsByUser[event.user];
				if (avatar != null) {
					avatar.removeEventListener(MouseEvent.CLICK, handleAvatarClick);
					avatarsGroup.removeElement(avatar);
					delete avatarsByUser[event.user];
				}
								
				var nameTag:NameTag = nameTagsByUser[event.user];
				if (nameTag != null) {
					nameTagGroup.removeElement(nameTag);
					delete nameTagsByUser[event.user];
				}
				
				var chatMessage:ChatMessage = stickyMessagesByUser[event.user];
				if (chatMessage != null) {
					textGroup.removeElement(chatMessage.chatBubble);
					delete stickyMessagesByUser[event.user];
				}
			}
			
			private function handleRoomCleared(event:PalaceRoomEvent):void {
				for each (var avatar:Object in avatarsByUser) {
					Avatar(avatar).removeEventListener(MouseEvent.CLICK, handleAvatarClick);
				}
				avatarsGroup.removeAllElements();
				avatarsByUser = new Dictionary();

				nameTagGroup.removeAllElements();
				nameTagsByUser = new Dictionary();
				
				currentlyDisplayedChatMessages.removeAll();
				chatQueue = [];
				textGroup.removeAllElements();
				
			}
			
			
			
			private function handleBGChange(event:PropertyChangeEvent):void {
				backgroundImage.visible = false;
				if (room.backgroundFile == null) {
					return;
				}
				forcingJpeg = false;
				forcingPng = false;
				var match:Array = room.backgroundFile.match(/^(.*)\.gif$/i);
				if (match != null) {
					baseBackgroundFile = match[1];
					tryPngBG();
				}
				else {
					backgroundImage.source = mediaServer + room.backgroundFile;
				}
			}
			
			private function tryJpegBG():void {
				if (baseBackgroundFile && baseBackgroundFile.length > 0) {
					trace("Trying to find jpeg version of background.");
					forcingJpeg = true; 
					backgroundImage.source = mediaServer + baseBackgroundFile + ".jpg";
				}
			}
			
			private function tryPngBG():void {
				if (baseBackgroundFile && baseBackgroundFile.length > 0) {
					trace("Trying to find png version of background.");
					forcingPng = true; 
					backgroundImage.source = mediaServer + baseBackgroundFile + ".png";
				}
			}
			
			private function tryRegularBG():void {
				trace("Unable to load preferred background images - Reverting to originally specified filename.");
				backgroundImage.source = mediaServer + room.backgroundFile;
			}
			
			private function handleBackgroundLoadComplete(event:Event):void {
				if (PalaceConfig.fadeBackgroundImages) { 
					backgroundImage.alpha = 0;
					var fade:Fade = new Fade(backgroundImage);
					fade.duration = 600;
					fade.alphaFrom = 0;
					fade.alphaTo = 1;
					fade.play();
				}
				backgroundImage.visible = true;
			}
			
			private function handleUnableToLoadBG():void {
				if (forcingPng) {
					forcingPng = false;
					tryJpegBG();
				}
				else if (forcingJpeg) {
					forcingJpeg = false;
					tryRegularBG();
				}
				else {
					backgroundImage.source = null;
				}
			}
			
			private function handleBGioERROR(event:IOErrorEvent):void {
				handleUnableToLoadBG();
			}
			
		]]>
	</fx:Script>
	
	<s:Rect width="100%" height="100%">
		<s:fill>
			<mx:SolidColor color="0x000000" />
		</s:fill>
	</s:Rect>
	
	<mx:Image top="0" left="0" id="backgroundImage" minHeight="384" minWidth="512"
		scaleContent="false" complete="handleBackgroundLoadComplete(event)"
		loaderContext="{PalaceClient.loaderContext}" ioError="handleBGioERROR(event);"
		visible="false" />
	
	<view:PalaceHotspotView id="hotSpotCanvas" room="{room}" mediaServer="{mediaServer}" hotSpots="{room.hotSpots}" top="0" right="0" bottom="0" left="0" />
	<mx:Canvas id="loosePropsCanvas" horizontalScrollPolicy="off" verticalScrollPolicy="off" top="0" right="0" bottom="0" left="0">
		<mx:Repeater id="loosePropsRepeater" dataProvider="{room.looseProps}">
			<mx:Image source="{loosePropsRepeater.currentItem.prop.bitmap}"
				alpha="{loosePropsRepeater.currentItem.prop.ghost ? 0.5 : 1.0}"
				x="{loosePropsRepeater.currentItem.x}"
				y="{loosePropsRepeater.currentItem.y}" />
		</mx:Repeater>
	</mx:Canvas>
	
	<s:Group id="avatarsGroup" top="0" right="0" bottom="0" left="0">
		<s:layout>
			<s:BasicLayout />
		</s:layout>
	</s:Group>
	
<!--	<mx:Canvas id="nameTagsCanvas" top="0" right="0" bottom="0" left="0" horizontalScrollPolicy="off" verticalScrollPolicy="off"  /> -->

	<s:Group id="nameTagGroup" mouseEnabled="false">
		<s:layout>
			<s:BasicLayout />
		</s:layout>
	</s:Group>

	<s:Group id="textGroup" mouseEnabled="false" top="0" right="0" bottom="0" left="0">
		<s:layout>
			<s:BasicLayout />
		</s:layout>
	</s:Group>
	
	<mx:ProgressBar bottom="0" width="100%"
		source="{backgroundImage}"
		visible="{!backgroundImage.visible &amp;&amp; backgroundImage.source != null &amp;&amp; progressBar.percentComplete &lt; 100}"
		labelPlacement="center"
		id="progressBar"
		label="Downloading Background... {Math.ceil(progressBar.percentComplete)}%" />

</s:Group>
