<?xml version="1.0" encoding="utf-8"?>

<!--
This file is part of OpenPalace.

OpenPalace is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

OpenPalace is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with OpenPalace.  If not, see <http://www.gnu.org/licenses/>.
-->

<s:SkinnableContainer xmlns:mx="library://ns.adobe.com/flex/halo"
	xmlns:s="library://ns.adobe.com/flex/spark" xmlns:fx="http://ns.adobe.com/mxml/2009"
	x="{user.x-this.width/2}" y="{user.y-this.height/2}"
	height="132"
	mouseEnabled="false"
	buttonMode="{!user.isSelf}"
	creationComplete="handleCreationComplete()"
	xmlns:filters="flash.filters.*">
	
	<fx:Script>
		<![CDATA[
			import spark.effects.Fade;
			import caurina.transitions.Tweener;
			import net.codecomposer.palace.event.PropEvent;
			import mx.core.FlexBitmap;
			import mx.events.CollectionEventKind;
			import mx.graphics.SolidColor;
			import spark.primitives.Rect;
			import mx.events.CollectionEvent;
			import net.codecomposer.palace.model.PalaceProp;
			import mx.binding.utils.ChangeWatcher;
			import mx.events.PropertyChangeEvent;
			import com.deviant.HueColorMatrixFilter;
			import mx.collections.ArrayCollection;
			import net.codecomposer.palace.model.PalaceUser;
			[Bindable]
			public var user:PalaceUser = new PalaceUser();
			
			// Faces
			[Embed(source="../../../../assets/faces/0.gif")]
			[Bindable]
			public static var face0:Class;
			
			[Embed(source="../../../../assets/faces/1.gif")]
			[Bindable]
			public static var face1:Class;
			
			[Embed(source="../../../../assets/faces/2.gif")]
			[Bindable]
			public static var face2:Class;
			
			[Embed(source="../../../../assets/faces/3.gif")]
			[Bindable]
			public static var face3:Class;
			
			[Embed(source="../../../../assets/faces/4.gif")]
			[Bindable]
			public static var face4:Class;
			
			[Embed(source="../../../../assets/faces/5.gif")]
			[Bindable]
			public static var face5:Class;
			
			[Embed(source="../../../../assets/faces/6.gif")]
			[Bindable]
			public static var face6:Class;
			
			[Embed(source="../../../../assets/faces/7.gif")]
			[Bindable]
			public static var face7:Class;
			
			[Embed(source="../../../../assets/faces/8.gif")]
			[Bindable]
			public static var face8:Class;
			
			[Embed(source="../../../../assets/faces/9.gif")]
			[Bindable]
			public static var face9:Class;
			
			[Embed(source="../../../../assets/faces/10.gif")]
			[Bindable]
			public static var face10:Class;
			
			[Embed(source="../../../../assets/faces/11.gif")]
			[Bindable]
			public static var face11:Class;
			
			[Embed(source="../../../../assets/faces/12.gif")]
			[Bindable]
			public static var face12:Class;
			
			[Bindable]
			private var faces:ArrayCollection = new ArrayCollection([
				face0,
				face1,
				face2,
				face3,
				face4,
				face5,
				face6,
				face7,
				face8,
				face9,
				face10,
				face11,
				face12,
				face0,
				face1,
				face2
			]);

			private var colors:Object = {};
			
			public static var chatBubbleTintColors:Array = [
				0xFF9999, // 0  Red
				0xFF9966, // 1  Orange
				0xFFCC88, // 2  Gold
				0xFFFFAA, // 3  Yellow
				0xD0F29F, // 4  Yellow-Green
				0xB9F29F, // 5  Green
				0xAFF2AE, // 6  Green 2
				0xC4F4DE, // 7  Green-Cyan
				0xA9EEF1, // 8  Cyan
				0x8DD2FF, // 9  Cyan-Blue
				0x86ABFF, // 10 Blue
				0x8F86FF, // 11 Blue-Violet
				0xAB86FF, // 12 Violet
				0xEF86FF, // 13 Magenta
				0xFF86E4, // 14 Magenta-Rose
				0xFF86B1  // 15 Rose
			]; 
			
			private var hue:HueColorMatrixFilter = new HueColorMatrixFilter();				
			
			private var imagesByProp:Dictionary = new Dictionary();
			
			private function updateFace(event:PropertyChangeEvent=null):void {
				if (user) {
					hue.reset();
					hue.Hue = colors[user.color];
					face.filters = [hue.Filter];
				}
			}
			
			private function handleCreationComplete():void {
				var startColor:int = -35;
				var interval:int = 360/16;
				for (var i:int = 0; i < 16; i++) {
					colors[i] = startColor + (interval * i);
				}
				
				var hitSprite:Sprite = new Sprite();
				hitSprite.x = 44;
				hitSprite.y = 44;
				hitSprite.graphics.clear();
				hitSprite.graphics.beginFill(0x000000, 0);
				hitSprite.graphics.drawRect(0,0,44,44);
				hitSprite.graphics.endFill();
				hitArea = hitSprite;
				
				updateFace();
				ChangeWatcher.watch(this, ['user','face'], updateFace);
				ChangeWatcher.watch(this, ['user','color'], updateFace);
				user.props.addEventListener(CollectionEvent.COLLECTION_CHANGE, handlePropsChange);
				
				loadProps();
			}
			
			private function loadProps():void {
				var numProps:int = user.props.length;
				for (var i:int = 0; i < numProps; i ++) {
					addProp(PalaceProp(user.props.getItemAt(i)));
				}
			}
			
			private function addProp(prop:PalaceProp):void {
				var image:Image;
				prop.addEventListener(PropEvent.PROP_LOADED, handlePropLoaded);
				image = new Image();
				var bitmap:FlexBitmap = FlexBitmap(prop.bitmap);
				image.source = bitmap;
				image.x = prop.horizontalOffset + 43;
				image.y = prop.verticalOffset + 43;
				image.alpha = prop.ghost ? 0.5 : 1.0;
				imagesByProp[prop] = image;
				propsGroup.addElement(image);
			}
			
			private function handlePropsChange(event:CollectionEvent):void {
				var prop:PalaceProp;
				var image:Image;
				switch (event.kind) {
					case CollectionEventKind.ADD:
						for each (prop in event.items) {
							addProp(prop);
						}
						break;
					case CollectionEventKind.REMOVE:
						for each (prop in event.items) {
							prop.removeEventListener(PropEvent.PROP_LOADED, handlePropLoaded);
							image = imagesByProp[prop];
							if (image != null) {
								propsGroup.removeElement(image);
								delete imagesByProp[prop];
							}
						}
						break;
					case CollectionEventKind.RESET:
						imagesByProp = new Dictionary();
						propsGroup.removeAllElements();
						break;
				}
			}
			
			private function handlePropLoaded(event:Event):void {
				var prop:PalaceProp = PalaceProp(event.target);
				var image:Image = imagesByProp[prop];
				if (image != null) {
					image.alpha = 0;
					image.source = prop.bitmap;
					image.x = prop.horizontalOffset + 43;
					image.y = prop.verticalOffset + 43;
					var fade:Fade = new Fade(image);
					fade.duration = 500;
					fade.alphaFrom = 0;
					fade.alphaTo = prop.ghost ? 0.5 : 1.0;
					fade.play();
				}
			}
			
			
		]]>
	</fx:Script>
	
	<s:layout>
		<s:BasicLayout />
	</s:layout>
	
	
	<mx:Image x="44" y="44" width="44" height="44" source="{faces.getItemAt(user.face)}" visible="{user.showFace}" id="face"/>

	<s:Group id="propsGroup" x="0" y="0" width="132" height="132"
		mouseEnabled="false">
		<s:layout>
			<s:BasicLayout />
		</s:layout>
	</s:Group>

</s:SkinnableContainer>
